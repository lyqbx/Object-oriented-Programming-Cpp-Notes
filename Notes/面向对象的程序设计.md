# 面向对象的程序设计
## 第1章 从C到C++
### 1.1 引用
1. 引用
    类型名 & 引用名 = 某变量名;
    ```c++
    int n = 4;
    int & r = n;
    ```
    引用要 **初始化** ，初始化之后不会再引用别的变量。

    ```c++
    int & r1 = a;
    int & r2 = r1; //r2也引用a
    ```

2. 引用作为函数的返回值
    ```c++
    int n = 4;
    int & SetValue(){ return n ;}
    int main()
    {
            SetValue() = 40;
            cout << n;
            return 0;
    }
    ```
3. 常引用：
   ```c++
   int n;
   const int & r = n; // r的类型是 const int &
   r = 200; // 编译出错，不能用常引用修改其引用的内容
   n = 300; // 编译正常
   ```
4. 常引用和非常引用的转换
### 1.2 const关键字
1. 定义常量指针
   ```c++
   int n, m;
   const int * p = & n;
   *p = 5; // 出错，不能用常量指针修改其指向的内容
   ```
    另外不能把常量指针赋值给非常量指针。
    函数参数为常量指针时，可避免函数内部不小心改变参数指针所指的内容。
### 1.3 动态内存分配
1. new 运算符
   - 分配一个变量
        `P = new T；`
        T是任意类型名，P的类型为T*。
        ```c++
        int* n;
        n = new int;
        *n = 5;
        ```
    - 分配一个数组
        `P = new T[N];`
        P为这块空间的起始地址
2. delete 运算符
    释放用 new 动态分配的内存空间
    ```c++
    int *p = new int[20];
    int *q = new int;
    delete [] p;
    delete q;
    ```
### 1.4 内联函数和重载函数函数参数缺省值
1. 内联函数
    - 目的：减少函数调用的开销
    在函数定义前加 **inline** 关键字
2. 函数重载
   - 函数的名字相同，参数表不同
3. 缺省参数
   - 定义函数时，最右边的连续若干个参数可以有默认值
  
## 第2章 类和对象基础
### 2.1 基本概念
1. 使用类的成员变量和成员函数
   ```c++
   CRectangle r1;
   r1.w = 5; // 用法1：对象名.成员名
   CRectangle *p1;
   p1->w = 5; // 用法2：指针->成员名
   CRectangle & rr = r1;
   rr.w = 5; //用法3：引用名.成员名
   ```
2. 类的成员函数和类的定义可以分开写
   在类中定义，在类外写成员函数
   `void CEmployee::setName(){}`
3. 类成员的可访问范围
   - private：私有成员，只能在成员函数内访问
   - public：公有成员，可以再任何地方访问
   - protected：保护成员，以后再说
    ```c++
    class Name{
        private:
        ...
        public:
        ...
        protected:
        ...
    };
    ```
    - 如果没有关键字，默认认为是私有的
    - 私有的成员不能在类的外部访问
4. “隐藏”的作用：如果以后成员变量的属性修改后，只需要修改成员函数即可，也就是统一对变量的管理
   ```c++
   class Name{
       private:
        char szname[20];
       public:
        void setName(char * name);
   }
   void Name::setName(char *name){
       strcpy(szName,name);
   };
   ```
5. 成员函数的重载及参数缺省
   避免二义性
   ```c++
   void valuex(int val = 0){ x = val;}
   int valuex(){ return x; }
   ```
### 2.2 构造函数
1. 概念
   成员函数的一种
   - 名字与类名相同，可以有参数，不能有返回值
   - 作用是对对象进行初始化，如给成员变量赋初值
   - 如果没写构造函数，会生成一个没用的构造函数
   - 对象生成时，就会调用构造函数
   - 一个类可以有多个构造函数
2. 为什么要构造函数
   - 不用写初始化函数，不用担心忘记初始化对象
   - 对象一定要初始化后使用
    ```c++
    class Complex{
        private:
            double real,imag;
        public:
            Complex(double r,double i = 0);
    };
    Complex::Complex(double r,double i){
        real = r;
        imag = i;
    }
    Complex c1(2);
    Complex *pc = new Complex(2);
    ```
    - 构造函数也可以有多个，只要参数表不同
3. 构造函数在数组中的使用
    ```c++
    class Test{
        public:
            Test(int n ){}          //(1)
            Test(int n,int m){}     //(2)
            Test(){}                //(3)
    };
    Test array1[3] = {1,Test(1,2)};
    // 三个元素分别用1,2,3初始化
    Test array2[3] = {Test(2,3),Test(1,2),1};
    // 2,2,1
    Test *pArray[3] = {new Test(4),new Test(1,2)};
    // 1,2 ，另外pArray[2]未生成对象
    ```
### 2.3 复制构造函数
1. 概念
   - 只有一个参数--对同类对象的引用。
   - X::X( X& obj) 或 X::X( const X& obj) 后者能以常量对象作为参数
   - 如果没有定义复制构造函数，编译器会生成默认的复制构造函数
   ```c++
   class Complex{
       private :
        double real,imag;
   };
   Complex c1;
   Complex c2(c1); // 调用缺省的复制构造函数，将c2初始化成和c1一样
   ```
   自定义的复制构造函数
   ```c++
   Complex(const Complex &c){
       real = c.real;
       imag = c.imag;
       cout << "copy";
   }
   ```
 2. 复制构造函数的作用：
    - 用一个对象初始化同类的另一个对象
    ```c++
    Complex c2(c1);
    Complex c2 = c1; //等价
    ```
    - 如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用
    ```c++
    void Func(A a1){}
    int main(){
        A a2;
        Func(a2);//调用复制构造函数，一般a1是a2的一个拷贝
        return 0;
    }
    ```
    - 如果函数的返回值是类A的对象时，则函数返回时A的复制构造函数会被调用
    ```c++
    A Func(){
        A b(4);
        return b;
    }
    int main(){
        cout << Func().v << endl; // 这里的Func() 是经过复制构造函数处理的b的复制
        return 0;
    }
    ```
    注：对象间的赋值不会调用复制构造函数，但是初始化时会调用
### 2.4 类型转换构造函数和析构函数
1. 类型转换构造函数
   - 目的：实现类型的自动转换
   - 只有一个参数，并且不是复制构造函数的构造函数
   - 当需要的时候，编译系统会自动调用类型转换构造函数，建立一个无名的临时对象
   ```c++
   class Complex{
       public:
        double real,imag;
        Complex( int i){//类型转换构造函数
            cout << "IntConstructor called" << endl;
            real = i;imag = 0;
        }
        Complex(double r,double i){real = r;imag = i;}
   };
   int main(){
       Complex c1(3,4);
       c1 = 9; // 9被自动转换成一个临时Complex对象
       return 0;
   }
   ```
2. 析构函数
    - 名字在类名前加一个~，无参数和返回值
    - 对象消亡时自动调用
    - 可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间
   ```c++
   class String{
       private:
        char* p;
       public:
        String(){
            p = new char[10];
        }
        ~String();
   };
   String :: ~String(){
       delete [] p;
   }
   ```
## 第3章 类和对象提高
### 3.1 this指针
**非静态**成员函数中，可以直接用this来代表指向该函数作用的对象的指针
```c++

class Complex{ 
     private:
    
public:
    double real, imag;
    void Print() { cout << real << ',' << imag << endl; }
    Complex(double r,double i);
    Complex AddOne(){
        this->real++;
        this->Print();
        return *this;
    }
};

Complex::Complex(double r, double i) : real(r), imag(i)
{

}
int main(){
    Complex c1(1, 1), c2(0, 0);
    c2 = c1.AddOne();
    return 0;
}
```
### 3.2 静态成员变量
1. 静态成员： 在定义前面加了static关键字的成员
   - 静态成员变量一共就一份，为所有对象共享
   - 普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象，且不需要通过对象就可以访问
2. 访问静态成员
   - 类名::成员名
   `CRectangle::PrintTotal();`
   - 对象名.成员名
   `CRectangle r;r.PrintTotal();`
   - 指针->成员名
   `CRectangle* p = &r; p->PrintTotal();`
   - 引用.成员名
   `CRectangle & ref = r; int n = ref.nTotalNumber;`
3. 一些概念
   - 静态成员变量是全局变量
   - 静态成员函数是全局函数
   - 设置静态成员的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体

    ```c++
    class CRectangle{
        private:
            int w,h;
            static int nTotalArea;
            static int nTotalNumber; // 静态成员变量
        public:
            CRectangle(int w_,int h_);
            CRectangle(CRectangle & r)
            {   //因为有时会调用复制构造函数生成临时的隐藏的CRectangle对象，
                //所以为了计算Number等，需要写一个复制构造函数
                w = r.w;
                h = r.h;
                nTotalNumber ++;
                nTotalArea += w*h;
            }
            ~CRectangle();
            static void PrintTotal(); // 静态成员函数
    };
    CRectangle::CRectangle(int w_,int h_)
    {
        w = w_;
        h = h_;
        nTotalNumber ++;
        nTotalArea += w*h;
    }
    CRectangle::~CRectangle()
    {
        nTotalNumber --;
        nTotalArea -= w*h;
    }
    void CRectangle::PrintTotal()
    {
        cout << nTotalNumber << "," << nTotalArea << endl;
        // cout << w;错误
        // 在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数
    }
    int CRectangle::nTotalNumber = 0;
    int CRectangle::nTotalArea = 0;
    // 必须在定义类的文件中对静态成员变量进行一次说明或初始化
    int main()
    {
        CRectangle r1(3,3),r2(2,2);
        CRectangle::PrintTotal();
        r1.PrintTotal();
        return 0;
    }
    ```
### 3.3 成员对象和封闭类
1. 有成员对象的类叫封闭类
    ```c++
    class CTyre //轮胎类
    {
        private:
            int radius,width;
        public:
            CTyre(int r,int w):radius(r),width(w){}
    };
    class CEngine //引擎类
    {
    };
    class CCar //汽车类
    {
        private:
            int price;
            CTyre tyre;
            CEngine engine;
        public:
            CCar(int p,int tr,int tw);
    };
    CCar::CCar(int p ,int tr,int w):price(p),tyre(tr,w){};
    int main(){
        CCar car(20000,17,225);
        return 0;
    }
    ```
    这里如果CCar类不定义构造函数，则`CCar car;`会编译出错，因为编译器不明白`car.tyre`该如何初始化，他没有默认的无参构造函数。`car.engine`的初始化没问题，用默认构造函数即可。
    对于封闭类，要通过封闭类的构造函数的初始化列表让编译器明白对象中的成员对象是如何初始化的。
2. 封闭类构造函数调用顺序
    - 封闭类对象生成时，先执行所有成员对象的构造函数，然后才执行封闭类的构造函数
    - 成员对象的构造函数调用次序和对象在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关
    - 析构函数次序和构造函数相反
3. 封闭类的复制构造函数
   封闭类的对象如果是用默认复制构造函数初始化的，那么它里面的成员对象也会用复制构造函数初始化。
### 3.4 常量对象、常量成员函数和常引用
1. 常量对象
    `const Demo Obj;`
    **常量对象只能使用构造函数、析构函数和常量方法！**
2. 常量成员函数
    - 在类的成员函数说明后面加上 **const**关键字
    - 常量成员函数执行期间 不应修改其作用的对象。因此在常量成员函数中不能修改成员变量的值（**静态成员变量除外**）。也不能调用同类的非常量成员函数（**静态成员函数除外**）
    ```c++
    class Sample
    {
        public:
            int value;
            void GetValue () const;
            void func(){};
            Sample(){}
    };
    void Sample::GetValue() const
    {
        value = 0;// wrong
        func();//wrong
    }
    int main(){
        const Sample o;
        o.value=100;//wrong
        o.func();//wrong
        o.GetValue;//right
        return 0;
    }
    ```
3. 常量成员函数的重载
   ```c++
   int GetValue() const {return n;} // 常量对象调用这个
   int GetValue(){return 2*n}; // 非常量对象会调用这个
   ```
4. 常引用
    可以用对象的 **常引用**作为参数，一不用调用复制构造函数，二函数中不会出现无意改变对象值的语句
### 3.5 友元
1. 友元函数
    一个类的友元函数可以访问该类的私有成员,也就是说友元函数不是这个类的成员函数
    ```c++
    class CCar; //提前声明CCar类，以便CDriver类使用
    class CDriver
    {
        public:
            void ModifyCar(CCar * pCar);// 如果这里参数是一个CCar对象，则CCar类需要在前面写完整
    };
    class CCar
    {
        private:
            int price;
        friend int MostExpensiveCar(CCar cars[],int total); // 声明友元函数，不是成员函数
        friend void CDriver :: ModifyCar(CCar * pCar); //把ModifyCar声明为CCar的友元函数
    };
    void CDriver::ModifyCar(CCar * pCar)
    {
        pCar->prive += 1000; // 访问了CCar的私有成员
    }
    int MostExpensiveCar(CCar cars[],int total)
    {
        int tmpMax = -1;
        for(int i=0;i<total;i++)
            if (cars[i].price > tmpMax) // 是全局函数，但是访问了CCar的私有成员
                tmpMax = cars[i].price;
            return tmpMax;
    }
    int main()
    {
        return 0;
    }
    ```

2. 友元类
    如果类A是B的友元类，那么A的成员函数可以访问B的私有成员
    ```c++
    class CCar
    {
        private:
            int price;
        friend class CDriver; //声明CDriver是CCar的友元类
    };
    class CDriver
    {
        public:
            CCar myCar;
            void ModifyCar()
            {
                myCar.price += 1000; //因为是友元类，所以可以访问CCar的私有成员
            }
    };
    ```
    - 友元类之间的关系不能传递，也不能继承。
---
## 第4章 运算符重载
### 4.1 运算符重载的基本概念
1. 形式
   返回值类型 operator 运算符 （形参表）{}
   ```c++
   class Complex
   {
       public:
        double real,imag;
        Complex (double r = 0.0,double i = 0.0):real(r),imag(i){}
        Complex operator-(const Complex& c); // 重载为成员函数，参数个数为运算符目数减一
   };
   Complex operator+(const Complex& a,const Complex& b) // 重载为普通函数，参数个数为运算符目数
   {
       return Complex(a.real+b.real,a.imag+b.imag); // 返回一个临时对象
   }
   Complex Complex::operator-(const Complex& c)
   {
       return Complex(real-c.real,imag-c.imag); // 返回一个临时对象
   }
   int main()
   {
        Complex a(4,4),b(1,1),c,d;
        c = a + b; // 等价于c=operator+(a,b)
        d = a - b; // 等价于d=a.operator-(b)
        return 0; 
   }
   ```
### 4.2 赋值运算符的重载
1. 示例
    ```c++
    class String
    {
        private:
            char *str;
        public:
            String():str(new char[1]){str[0]=0;}
            const char *c_str(){return str;};
            String &operator=(const char *s);
            ~String(){delete [] str;}
    };
    String &String::operator = (const char* s)
    {   //重载“=”，使得obj="hello"能够成立
        delete [] str;
        str = new char[strlen(s)+1];
        strcpy(str,s);
        return *this;
    }
    int main()
    {
        String s;
        s = "Good Luck"; //等价于s.operator=("Good Luck")
        //String s2 = "hello" 错误，因为是初始化而不是赋值
    }
    ```
2. 浅拷贝和深拷贝：
    ```c++
    String s1,s2;
    s1 = "this";
    s2 = "that";
    s1 = s2; //这是浅拷贝，s1和s2都指向s2的字符串，如果s1对象消亡，执行s1的析构函数，delete一次
             //s2消亡时也会delete一次，出错
    String & operator=(const String& s)
    {
        if(this == &s)
            return *this; //为了应对s=s的情况
        delete [] str;
        str = new char[strlen(s.str)+1];
        strcpy(str,s.str);
        return *this;
    }
    ```
3. 对operator=返回值类型的讨论
   void,String其实都可以，但是为了保持原=的特性
   考虑: `a=b=c; //先b=c,然后a=(b=c)的返回值`
        `(a=b)=c; //(a=b)的返回值是a的引用,非引用的函数返回值不能作为赋值运算符的左值`
        如果不用引用，用String，那么返回的就是用复制构造函数创造的一个拷贝
4. 还要对复制构造函数处理
    ```c++
    String(String &s)
    {
        str = new  char[strlen(s.str)+1];
        strcpy(str,s.str);
    }
    ```
### 4.3 运算符重载为友元
1. 引入
   - 一般情况下，将运算符重载为类的成员函数是较好的选择
   - 但有时，重载为成员函数不能满足使用要求，重载为普通函数又不能访问类的私有成员，所以需要将运算符重载为友元
   - 在类中重载双目运算符的话，就只要设置一个参数作为右侧参数，左侧运算量就是对象本身
   - 例如<<,>>的左侧运算量是cout,cin，所以不满足这一点，就只能声明为友元函数
   - 一般将双目运算符重载为友元函数，这样还可以使用交换律（比如+，-）
   - 总之，如果运算符重载为成员函数， **第一个参数必须是类的对象！**
    ```c++
    class Complex
    {
        double real,imag;
        public:
            Complex(double r,double i):real(r),imag(i){};
            Complex operator+(double r);
            friend Complex operator+(double r,const Complex &c);
    };
    Complex Complex::operator+(double r)
    {
        return Complex(real + r.imag);  //这种方式c=c+5 OK，但是c=5+c ERROR
    }
    Complex operator+(double r,const Complex &c)
    {
        return (r+c.real,r.imag);   // 能解释5+c
    }
    ```
### 4.4 可变长数组的实现
1. 目的
   ```c++
   int main(){
       CArray a; //开始数组是空的
       for(int i=0;i<5;i++)
            a.push_back(i); // 能添加新元素
        Carray a2,a3;
        a2 = a; // 要求深拷贝,要重载 = 
        a2 = a3; // a2为空了
        cout a2.length(); // 获得数组长度
        a[3] = 100; // 能赋值,要重载 []
        CArray a4(a); // 复制构造函数
   }
   ```
2. 实现
   ```c++
   class CArray
   {
       int size; //数组元素个数
       int *ptr; //指向动态分配的数组
       public:
        CArray(int s = 0); //s代表数组元素个数
        CArray(CArray &a);
        ~CArray();
        void push_back(int v);
        CArray &operator=(const CArray &a);
        int length(){ return size;}
        int & CArray::operator[](int i) // []的两个参数分别为数组名和其中的数字，返回值不能是int ,否则不支持a[i]=4
            return ptr[i];
   };
   CArray::CArray(int s):size(s)
   {
       if(s==0)
        ptr = NULL;
       else
        ptr = new int[s];
   }
   CArray:: CArray(CArray &a)
   {
       if(!a.ptr)
       {
            ptr = NULL; 
            size = 0; 
            return;
       }
       ptr = new int[a.size];
       memcpy(ptr,a.ptr.sizeof(int) * a.size);
       size = a.size;
   }
   CArray::~CArray()
   {
       if(ptr)  delete [] ptr;
   }
   CArray & CArray::operator=( const CArray &a)
   {
       if( ptr == a.ptr) // 防止a=a   
            return *this;
        if(a.ptr = NULL)
        {
            if(ptr)
                delete [] ptr;
            ptr = NULL;
            size = 0;
            return * this;
        }
        if(size < a.size)
        {
            if(ptr) delete [] ptr;
            ptr = new int [a.size];
        }
        memcpy( ptr,a.ptr,sizeof(int) * a.size);
        size = a.size;
        return * this;
   }
   void CArray::push_back(int v)
   {
        if(ptr)
        {
            int *temPtr = new int [size+1];
            memcpy(temPtr,ptr,sizeof(int)*size);
            delete [] ptr;
            ptr = temPtr;
        }
        else
            ptr = new int[1];
        ptr[size++] = v;
   }
   ```

### 4.5 流插入运算符和流提取运算符
1. cout 是 ostream 类的对象
    - 左移运算符能用在cout是因为 iostream里对<<进行了重载
    - 如何实现`cout << 5 << "this";`
        ```c++
        ostream & ostream:: operator<<(int n)
        {
            ...// 输出n的代码
            return * this;
        }
        ```
2. 重载左移运算符
   ```c++
   class CStudent{
       public: int age;
   };
   ostream & operator<<(ostream & o,const CStudent &s)
   {
       o<<s.age;
       return o;
   }
   ```

3. 例题
   假定c是Complex类的对象，实现`cout << c`,能以a+bi的形式输出；实现`cin >> c`，能以a+bi的形式输入

    ```c++
   #include <iostream>
   #include <string>
   #include <cstdlib>
   using namespace std;
   class Complex{
       double real,imag;
       public:
            Complex (double r=0, double i=0):real(r),imag(i){};
            friend ostream& operator<<( ostream &os,const Complex &c);
            friend istream& operator>>( istream &is,Complex &c);
    };
    ostream& operator<<( ostream &os,const Complex &c)
    {
       os << c.real << "+" << c.imag << "i"; 
        return os;
    }
    istream& operator>>( istream &is,Complex &c)
    {
        string s;
        is >> s; //将a+bi 作为字符串输入
        int pos = s.find("+",0);
        string sTmp = s.substr(0,pos); // 分离出代表实部的字符串
        c.real = atof(s.Tmp.c_str());
        sTmp = s.substr(pos+1,s.length()-pos-2); // 分离处代表虚部的字符串
        c.imag = atof(s.Tmp.c_str());
        return is; 
    }
    ```

### 4.6 类型转换运算符的重载
`operator double(){ return real; }`
### 4.7 自增自减运算符的重载
1. 前置和后置的区别
    - 前置运算符
        - 重载为成员函数：
        > T & operator++();
        > T & operator--();
        - 重载为全局函数：
        > T1 & operator++(T2);
        > T2 & operator--(T2);
    - 后置运算符,多写一个无用的参数
        - 重载为成员函数：
        > T & operator++(int);
        > T & operator--(int);
        - 重载为全局函数：
        > T1 & operator++(T2,int);
        > T2 & operator--(T2,int);
2. 示例
    ```c++
    class CDemo
    {
        private: 
            int n;
        public:
            CDemo(int i = 0):n(i){}
            // 成员函数
            CDemo & operator++(); // 用于前置形式 ++a 的返回值是&a，可以执行(++a)=1
            CDemo operator++(int); // 用于后置形式 a++ 的返回值是临时对象，是a在加一之前的值
            operator int(){ return n; } //可以直接cout << d,是隐藏的强制类型转换
            // 全局函数
            friend CDemo & operator--(CDemo &);// 用于前置形式
            friend CDemo operator--(CDemo &,int);// 用于后置形式
    };
    
    CDemo & CDemo::operator++()
    {   // 前置++
        ++ n;
        return *this;
    }
    CDemo CDemo::operator++(int k)  // 这是一个无用参数，代表后置
    {   // 后置++
        CDemo tmp(*this);   // 记录修改前的对象
        n ++;
        return tmp;
    }
    CDemo & operator--(CDemo &d) //这里传递引用，才能改变实参
    {   // 前置--
        d.n--;
        return d;
    }
    CDemo & operator--(CDemo &d,int k)
    {   // 后置--
        CDemo tmp(d);
        d.n--;
        return tmp;
    }
    
    ```

3. 注意事项
    1.   运算符重载不改变优先级
    2. . .* :: ?: sizeof 不能被重载
    3. (),[],->,=运算符重载必须声明为类的成员函数  
--- 
## 第5章 继承
### 5.1 继承的基本概念
1. 继承
   在定义一个新的类B时，如果类B拥有类A的全部特点，那么可以把A作为一个 **基类** ，类B作为A的 **派生类**
   - 派生类可以对基类进行修改和扩充
   - 派生类一经定义后，可以独立使用，不依赖于基类
   - 派生类的成员函数不能访问基类的Private成员
2. 写法
   class 派生类名：public 基类名{};
   ```c++
   class CStudent
   {
        private:
            string sName;
            int nAge;
        public:
            bool IsThreeGood(){};
            void SetName( const string & name )
            {
                sName = name;
            }
   };
   class CUndergraduateStudent:public CStudent
   {
        private:
            int nDepartment;
        public:
            bool IsThreeGood(){}; // 覆盖
            bool CanBaoYan(){};
   }
   ```
3. 派生类对象的内存空间
    派生类的体积 = 基类对象的体积 + 派生类对象的体积
    基类对象的存储位置位于派生类新增对象的前面

### 5.2 继承关系和复合关系
1. 继承：“是”关系
   - 基类A,B是基类A的派生类
   - 逻辑上要求：“一个B对象也应该是一个A对象” 例：一个中学生是一个学生
2. 复合关系：“有”关系
    - 类C中“有”成员变量k，k是类D的对象，则C和D是复合关系
    - 逻辑上要求：“D对象时C对象的固有属性或组成部分”
3. 举例
   ```c++
   // 不合理的
   class CPoint
   {
       double x,y;
   };
   class CCircle: public CPoint
   {
       double r;
   };

   //合理的
   class CPoint
   {
       double x,y;
       friend class CCircle;
   }
   class CCircle
   {
       CPoint p;
       double r;
   };
   ```
4. 复合关系的使用 
    人养狗的例子
    ```c++
    // 错误的循环定义
    class CDog;
    class CMaster
    {
        CDog dogs[10];
    };
    class CDog
    {
        CMaster m;
    };

    // 无法维护同主人狗的主人信息
    class CDog;
    class CMaster{
        CDog *dogs[10];
    };
    class CDog{
        CMaster m;
    };

    // 凑合的写法，因为狗不是主人的固有属性或者组成成分且对狗操作时必须通过主人
    class CMaster;
    class CDog{
        CMaster *pm;
    };
    class CMaster{
        CDog dogs[10];
    };

    // 正确的写法
    class CMaster;
    class CDog{
        CMaster *pm;
    };
    class CMaster{
        CDog *dogs[10];
    };
    ```
### 5.3 覆盖和保护成员
1. 覆盖：
    派生类可以定义一个和基类成员同名的成员，就是 **覆盖**。在派生类访问由基类定义的同名成员时，要是用作用域符号::
2. 保护成员
    - 基类的private成员可被下列函数访问
        - 基类的成员函数
        - 基类的友元函数
    - 基类的public成员
        - 基类的成员函数
        - 基类的友元函数
        - 派生类的成员函数
        - 派生类的友元函数
        - 其他的函数
    - 基类的protected成员
        - 基类的成员函数
        - 基类的友元函数
        - 派生类的成员函数

### 5.4 派生类的构造函数
1. 示例
   ```c++
   class Bug{
        private:
            int nLegs;
            int nColor;
        public:
            int nType;
            Bug( int legs, int color ):nLegs(legs),nColor(color){}
            void PrintBug(){}
   };
   class FlyBug: public Bug
   {
       int nWings;
       public:
            FlyBug(int legs,int color,int wings):Bug(legs,color),nWings(wings){}
   };
   ```
2. 注意
   - 先调用基类的构造函数，再构造派生类的构造函数
   - 调用基类构造函数的两种方式
     - 显式方式：在派生类的构造函数中为基类的构造函数提供参数
        `derived::derived(arg_derived-list):base(arg_base-list)`
     - 隐式方式：在派生类的构造函数中，省略基类构造函数时，派生类的构造函数自动调用基类的默认构造函数
   - 派生类的析构函数被执行后自动调用基类的析构函数
3. 一个派生类同时也是封闭类
   ```c++
   class Skill{
       public:
            Skill(int n){}
   };
   class FlyBug:public Bug{
       int nWings;
       Skill sk1.sk2;
       public: 
            FlyBug(int legs, int color, int wings);
   };
   FlyBug::FlyBug(int legs,int color, int wings):Bug(legs,color),sk1(5),sk2(color),nWings(wings){}
   ```
4. 封闭派生类对象的构造函数执行顺序
    1. 基类的构造函数
    2. 成员对象类的构造函数
    3. 派生类自己的构造函数 
### 5.5 公有继承的赋值兼容规则
 1. 派生类对象可以赋值给基类对象
 2. 派生类对象可以初始化基类的引用
 3. 派生类对象的地址可以赋值给基类指针
---
## 第6章 多态
### 6.1 虚函数和多态概念
1. 虚函数
   在类的定义中，前面有virtual关键字的成员函数
    ```c++
   class Base{
       virtual int get();
   };
   int Base::get(){}
    ```
    - virtual 关键字只用在类定义里的函数声明中，写函数体时不用
    - 构造函数和静态成员函数不能是虚函数
2. 多态的表现形式
   1. 派生类的指针可以赋给基类指针
    通过基类指针调用基类和派生类中同名 **虚函数**时：
       1. 若该指针指向一个基类对象，那么被调用的是基类的虚函数
       2. 若该指针只想一个派生类对象，那么被调用的是派生类的虚函数
   2. 派生类的对象可以赋给基类引用
      1. 同上
    ```c++
    class CBase{
        public:
            virtual void f(){}
    };
    class CDerived:public CBase{
        public:
            virtual void f(){}
    };
    int main(){
        CDerived ODerived;
        CBase * p = & ODerived;
        CBase &r = ODerived;
        p->f(); // 调用哪个虚函数取决于p指向哪种类型的对象
        r.f();  //同上
        return 0;
    } 
    ```
### 6.2 多态实例：魔法门之英雄无敌

```c++
    class CCreature {
        protected:
            int m_nLifeValue,m_nPower;
        public:
            virtual void Attack( CCreature * pCreature ){}
            virtual void Hurted( int nPower ){}
            virtual void FightBack( CCreature * pCreature ){} 
    };
    class CDragon:public CCreature {
        public:
            virtual void Attack( CCreature * pCreature );
            virtual void Hurted( int nPower );
            virtual void FightBack( CCreature * pCreature );
    };
    void CDragon::Attack( CCreature * p)
    {
        p->Hurted(m_nPower);
        p->FightBack(this);
    }
    void CDragon::Hureted( int nPower )
    {
        m_nLifeValue -= nPower;
    }
    void CDragon::FightBack( CCreature * p )
    {
        p->Hurted(m_nPower/2);
    }

    int main(){
        CDragon Dragon;
        CWolf Wolf;
        CGhost Ghost;
        Dragon.Attack( & Wolf );
        Dragon.Attack( & Ghost )
    }
```

### 6.3 多态实例：几何形体程序
要求：输入若干个几何形体的参数，要求按面积排序输出，输出时要指明形状
```c++
    #include <iostream>
    #include <stdlib.h>
    #include <math.h>
    using namespace std;
    
    class CShape
    {
        public:
            virtual double Area() = 0;  //纯虚函数
            virtual void PrintInfo() = 0;
    };

    class CRectangle:public CShape
    {
        public:
            int w,h;
            virtual double Area();
            virtual void PrintInfo();
    };

    class CCircle:public CShape
    {
        public:
            int r;
            virtual double Area();
            virtual void PrintInfo();
    };

    double CRectangle::Area(){
        return w * h;
    }
    void CRectangle::PrintInfo(){
        cout << "Rectangle:" << Area() << endl;
    }

    double CCircle::Area(){
        return 3.14*r*r;
    }
    void CCircle::PrintInfo(){
        cout << "Circle" << Area() << endl;
    }

    CShape *pShapes[100];
    int MyCompare(const void *s1, const void *s2);

    int main()
    {
        int i,n;
        CRectangle *pr;
        CCircle *pc;
        cin >> n;
        for( i=0; i<n; i++)
        {
            char c;
            cin >> c;
            switch(c){
                case 'R':
                    pr = new CRectangle();
                    cin >> pr->w >> pr->h;
                    pShapes[i] = pr;
                    break;
                case 'C':
                    pc = new CCircle();
                    cin >> pc->r;
                    pShapes[i] = pc;
                    break;
            }
        }
        qsort(pShapes,n,sizeof( CShape* ),MyCompare);   // 一个内置快排函数 第四个参数要求是fuc(const void*,const void*)
        for(i=0;i<n;i++)
            pShapes[i]->PrintInfo();
        return 0;
    }

    int MyCompare( const void *s1,const void *s2)
    {
        double a1,a2;
        CShape **p1; // s1是void *,不能用*s1获取s1指向的内容，因为不知道类型
        CShape **p2;
        p1 = (CShape**)s1; // s1指向pShapes数组中的元素，数组元素的类型是CShape*
        p2 = (CShape**)s2;
        a1 = (*p1)->Area();
        a2 = (*p2)->Area();
        if(a1<a2)
            return -1;
        else if(a2 < a1)
            return 1;
        else
            return 0;
    }
```

注意
   - 在构造函数和析构函数中调用虚函数就不是多态
   - 在非构造函数，非析构函数的成员函数中调用虚函数是多态
   - 派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数
### 6.4 多态的实现原理
1. 虚函数表
    每一个有虚函数的类（或者有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。
2. 多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中找到虚函数地址，并调用虚函数的指令
### 6.5 虚析构函数、纯虚函数和抽象类
1. 虚析构函数
    - 通过基类的指针删除派生类对象时，通常只调用基类的析构函数，但是删除一个派生类对象时，理应先调用派生类的析构函数，再调用基类的析构函数
   -  解决方法：把基类的析构函数声明为 virtual
      -  派生类的析构函数可以不声明
      -  通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数
   - 一般来说，一个类的析构函数定义为虚函数
   - 注：构造函数不能为虚函数
2. 纯虚函数
   - 没有函数体的虚函数
   - `virtual void Print() = 0;`
3. 抽象类
    - 包含纯虚函数的类叫抽象类
      - 抽象类只能作为基类来派生新类来使用，不能创建抽象类的对象
      - 抽象类的指针和引用可以指向由派生类派生出来的类的对象
    - 在抽象类的成员函数内可以调用纯虚函数（在成员函数中调用虚函数是多态 this->func();），但在构造函数或析构函数内部不能调用纯虚函数
    - 如果一个类从抽象类派生而来，那么当且仅当它实现了基类中所有纯虚函数，即给了他们{}，它才能成为非抽象类
--- 
## 第7章 输入输出和模板
### 7.1 输入输出流相关的类
1. 类
   
        ios -> istream -> ifstream  
                       -> iostream -> fstream  
            -> ostream -> ofstream  

    - istream 是用于输入的流类，cin 就是该类的对象。
    - ostream 是用于输出的流类，cout 就是该类的对象。
    - ifstream 是用于从文件读取数据的类。
    - ofstream 是用于向文件写入数据的类。
    - iostream 是既能用于输入，又能用于输出的类。
    - fstream 是既能从文件读取数据，又能向文件写入数据的类。
2. 标准流对象
   - 输入流对象：cin 
   - 输出流对象：cout 
                cerr 与标准错误输出设备相连
                clog 与标准错误输出设备相连
3. 判断输入流结束
   ```c++
   int x;
   while(cin >> x)
   ```
   - 如果是从文件输入，比如前面有`freopen("some.txt","r",stdin);`，那么读到文件末尾，输入流就算结束
   - 如果从键盘输入，则在单独一行输入\<C-Z\>代表输入流结束
4. istream 类的成员函数
   `istream & getline(char *buf,int bufSize); `
   从输入流中读取bufSize-1 个字符到缓冲区buf，或碰到'\n'为止。 
   `istream & getline(char *buf,int bufSize,char delim);`
   从输入流中读取bufSize-1 个字符到缓冲区buf，或碰到delim字符为止。

   两个函数都会在buf中读取数据的结尾添加'\0'。'\n'或者delim字符不会读入buf,但会被从输入流中取走。
   如果输入流中结束符之前的字符个数 **达到或超过**了bufSize个，就导致读入出错，结果是：虽然本次读入已经完成，但是之后的读入就都会失败了。

   可以用 `if(!cin.getline(...))`判断输入是否结束，输入错误时执行

    `bool eof();` 判断输入流是否结束
    `int peek();` 返回下一个字符，但不从流中去掉
    `istream & putback(char c);` 将字符ch放回输入流
    `istream & ignore(int nCount = 1,int delim = EOF);` 从流中删掉最多nCount字符，遇到EOF时结束

    ```c++
    #include <iostream>
    using namespace std;
    int main(){
        int x;
        char buf[100];
        cin >> x;   
        cin.getline(buf,90);
        cout << buf << endl;
        return 0;
        /*  输入：
            12 abcd
            输出：
             abcd(空格+abcd)
            输入：
            12
            程序立即结束，无输出
            因为getline读到留在流中的'\n'，直接返回
        */
    }
    ```
5. 输出重定向
    ```c++
   int main(){
       int x,y;
       cin >> x >> y;
       freopen("test.txt","w",stdout);  //将标准输出重定向到test.txt文件
       if(y==0)
           cerr << "error" << endl;
        else 
            cout << x/y; 
        return 0;
   }
    ```
6. 输入重定向
    ```c++
   int main(){
       double f; int n;
       freopen("t.txt","r",stdin);  // cin被改为从t.txt中读取数据
       cin >> f >> n;
       return 0;
   }
    // 用freopen("CON","r",stdin) 和freopen("CON","w",stdout)恢复
    ```

### 7.2 用流操纵算子控制输出格式
1. 流操纵算子
   #include \<iomanip\>
   **想格式化输出就去查**

### 7.3 文件读写（一）
1. 创建文件
   - #include \<fstream\>
   - `ofstream outFile("clients.dat",ios::out|ios::binary); //创建文件`
     - clients.dat      要创建的文件的名字
     - ios::out         文件打开方式
       - ios::out       输出到文件，删除原有内容
       - ios::app       输出到文件，保留原有内容，在尾部添加
     - ios::binary      以二进制文件格式打开文件
   - 也可以先创建ofstream对象，再用open函数打开
        ```c++
        ofstream fout;
        fout.open("test.out",ios::out|ios::binary);
        ```
   - 判断打开是否成功
        ```c++
        if(!fout){
            cout << "File open error!" << endl;
        }
        ```
   - 文件名可以给出绝对路径，也可以给出相对路径
     - 绝对路径
        "c:\\\tmp\\\mydir\\\some.txt"
     - 相对路径
        "tmp\\\mydir\\\some.txt"
2. 文件的读写指针
   - 对于输入文件，有一个读指针
   - 对于输出文件，有一个写指针
   - 对于输入输出文件，有一个读写指针
   - 标识文件操作的当前位置，该指针在哪里，读写操作就在哪里进行
    ```c++
    ofstream fout("a1.out",ios::app);   // 以添加方式打开
    long location = fout.tellp();   // 取得写指针的位置
    location = 10;
    fout.seekp(location);   // 将写指针移动到第10个字节处
    fout.seekp(location,ios::beg);  // 从头数location
    fout.seekp(location,ios::cur);  // 从当前位置数location
    fout.seekp(location,ios::end);  // 从尾部数location
    // location 可以为负值

    ifstream fin("a1.in",ios::ate); // 打开文件，定位文件指针到文件尾
    long location = fin.tellg();   // 取得读指针的位置
    location = 10；
    fout.seekg(location,ios::beg);  // 从头数location
    fout.seekg(location,ios::cur);  // 从当前位置数location
    fout.seekg(location,ios::end);  // 从尾部数location
    ```
3. 显式关闭文件
     ```c++
    ifstream fin("test.dat",ios::in);
    fin.close();

    ofstream fout("test.dat",ios::out);
    fout.close();
    ```
4. 字符文件读写
   - 因为文件流也是流，所以流的成员函数和流操纵算子也同样适用于文件流。
   - 写一个程序，将文件in.txt里面的整数排序后，输出到out.txt
    ```c++
    #include <iostream>
    #include <fstream>
    #include <vector>
    #include <algorithm>
    using namespace std;
    int main(){
        vector<int> v;
        ifstream srcFile("in.txt",ios::in);
        ofstream destFile("out.txt",ios::out);
        int x;
        while(srcFile >> x)
            v.push_back(x);
        sort(v.begin(),v.end());
        for( int i = 0;i < v.size();i++ )
            destFile << v[i] << " ";
        destFile.close();
        srcFile.close();
        return 0;
    }
    ```
### 7.4 文件读写（二）
1. 二进制文件读写
   - 二进制读文件：
        ifstream 和 fstream 的成员函数：
        `istream &read (char* s,long n);`
        将文件读指针指向的地方的n个字节内容，读入到内存地址s，然后将文件读指针向后移动n字节（以ios::in方式打开文件时，文件读指针开始指向文件开头）
   - 二进制写文件：
        ofstream 和 fstream 的成员函数：
        `ostream &write (const char* s,long n);`
        将内存地址s处的n个字节内容，写入到文件中写指针指向的位置，然后将文件写指针向后移动n字节（以ios::out方式打开文件时，文件写指针开始指向文件开头，以ios::app方式打开文件时，文件指针开始指向文件尾部）。
   - 在文件中写入和读取一个整数
    ```c++
    #include <iostream>
    #include <fstream>
    using namespace std;
    int main(){
        ofstream fout("some.dat",ios::out|ios::binary);
        int x = 120;
        fout.write( (const char *)(&x),sizeof(int));
        fout.close();
        ifstream fin("some.dat",ios::in|ios::binary);
        int y;
        fin.read((char *) &y,sizeof(int));
        fin.close();
        cout << y << endl;
        return 0;
    }
    ```
    - 从键盘输入几个学生的姓名和成绩，并以二进制文件形式保存
    ```c++
    #include <iostream>
    #include <fstream>
    using namespace std;
    struct Student{
        char name[20];
        int score;
    };
    int main(){
        Student s;
        ofstream OutFile("c:\\tmp\\students.dat",ios::out|ios::binary);
        while(cin >> s.name >> s.score)
            OutFile.write((char *)&s,sizeof(s));    // 这样读入数据便于将来管理，每一个成员都是sizeof(s)大小
        OutFile.close();

        Student r;
        ifstream inFile("students.dat",ios::in|ios::binary);
        if(!inFile){
            cout << "error" << endl;
            return 0;
        }
        while(inFile.read((char *) &r,sizeof(r))){
            cout << r.name << r,score << endl;
        }
        inFile.close();
        return 0;
    }
    ```
    - 将student.dat文件中Jane的名字改为Mike
    ```c++
    /*文件内容
    Tom 60
    Jack 80
    Jane 40
    */
    int main(){
        Student s;
        fstream iofile("c:\\tmp\\students.dat",ios::in|ios::out|ios::binary);
        if(!iofile){
            cout << "error" << endl;
            return 0;
        }
        iofile.seekp( 2 * sizeof(s),ios::beg ); // 定位写指针到第三个记录
        iofile.write("Mike",strlen("Mike")+1);  // 这里是因为 '\0'
        iofile.seekg(0,ios::beg);   //定位读指针到开头
        while( iofile.read( (char* )& s,sizeof(s)) )
            cout << s.name << " " << s.score << endl;
        iofile.close();
        return 0;
    }
    ```
   - 文件拷贝程序mycopy示例
    ```c++
    #include <iostream>
    #include <fstream>
    using namespace std;
    int main(int argc,char* argv[]) // 带命令行参数，分别代表命令行参数的个数和命令行参数，使用方法：mycopy src.dat dest.dat
    {
        if(argc != 3){
            cout << "File name missing!" << endl;
            return 0;
        }
        ifstream inFile(argv[1],ios::in|ios::binary);    // argv[1]就是src.dat
        if(!inFile){
            cout << "Source file open error." << endl;
            return 0;
        }
        ofstream outFile(argv[2],ios::out|ios::binary);
        if(!outFile){
            cout << "New file open error." << endl;
            inFile.close();
            return 0;
        }
        char c;
        while( inFile.get(c))   // 每次读入一个字符 get()参数是char &
        // 有文件缓冲区，即使只get()一次，操作系统也把文件中更大一部分数据放在内存中
            outFile.put(c); // 每次写入一个字符            
        outFile.close();
        inFile.close();
        return 0;
    }
2. 二进制文件和文本文件的区别
   比如不同操作系统下换行的符号不同，用不用ios::binary对于windows下有区别，unix/linux无区别
   Windows下如果不用ios::binary，则：
    - 读取文件时，所有的'\r\n'会被当做一个字符'\n'处理，即少读了一个字符'\r'。
    - 写入文件时，写入单独的'\n'时，系统自动在前面加一个'\r'。
### 7.5 函数模板
1. 函数模板
   template \<class 类型参数1，class 类型参数2,......\>
   返回值类型 模板名（形参表）
   {
       函数体
   }
   ```c++
   template <class T>
   void swap (T &x,T &y)
   {
       T tmp = x;
       x = y;
       y = tmp;
   }
   int main()
   {
       int n = 1,m = 2;
       swap(n,m);   // 编译器自动生成 void swap(int &,int&)函数
       double f = 1.2, g = 2.3;
       swap(f,g);   //void swap(double &,double &)
   }
   ```
   - 求数组最大元素的模板
    ```c++
    template <class T>
    T MaxElement (T a[], int size)
    {
        T tmpMax = a[0];
        for( int i = 1;i < size; ++i)
            if(tmpMax < a[i])
                tmpMax = a[i];
        return tmpMax;
    }
    ```
    - 不通过参数实例化函数模板
    ```c++
    T Inc( T n )
    {
        return 1+n;
    }
    int main()
    {
        cout << Inc<double>(4)/2;   // 尖括号里代表，把Inc实例化成T为double的模板，然后加上(4)就是调用了这个函数
        return 0;
    }
    ```
2. 函数模板的重载
   - 函数模板可以重载，只要它们的 **形参表或类型参数表** 不同即可。
    ```c++
    template<类型参数表>
    void func(形参表)
    ```
3. 函数模板和函数的次序
    1. 先找参数完全匹配的 **普通函数**
    2. 再找参数完全匹配的 **模板函数**
    3. 再找实参经过自动类型转换后能匹配的 **普通函数**
    4. 上面都没有则会报错
   - 匹配模板函数时，不进行类型自动转换
4. 函数模板示例：Map
    ```c++
    template<class T,class Pred>
    void Map( T s, T e, T x, Pred op)   // 把一个[s,e)的区间中每一个元素，通过op进行变换，拷贝到目标区间x
    // 这里的Pred op实际上是一个函数指针形参
    {
        for(; s!=e;++s;++x){
            *x = op(*s);
        }
    }

    int Cub(int x) { return x*x*x; }
    double Square(double x) { return x*x；}

    int a[5] = {1,2,3,4,5},b[5];
    double c[5] = {1.1,2.2,3.3,4.4,5.5},d[5];

    Map(a,a+5,b,Square);    // 实例化以下函数
    void Map(int *s, int *e, int *x, double(*op)(double)) // 这里就是一个参数为一个double,返回值是double的函数指针
    {
        for(;s!=e;++s,++x)
            *x = op(*s);    
    }
    ```
### 7.6 类模板
1. 类模板的定义
   - 类模板
    ```c++
    template <class 类型参数1，class 类型参数2,...>
    class 类模板名
    {
        成员函数和成员变量
    };
    ```
   - 类模板成员函数的写法
    ```c++
    返回值类型 类模板名<类型参数名列表>::成员函数名(参数表)
    {
    }
    ```
   - 用类模板定义对象的写法
    `类模板名<真实类型参数表> 对象名(构造函数实参表);`
2. 类模板示例：Pair类模板
    ```c++
    template <class T1,class T2>
    class Pair
    {
        public:
            T1 key;
            T2 value;
            Pair(T1 k,T2 v):key(k),value(v){};
            bool operator < (const Pair<T1,T2> &p) const;
    };
    template<class T1,class T2>
    bool Pair<T1,T2>::operator < (const Pair<T1,T2> &p> const
    {
        return key<p,key;
    }

    int main()
    {
        Pair<string,int> student("Tom",19);
    }
    ```
3. 函数模板作为类模板成员
    ```c++
    template <class T>
    class A
    {
        public:
        template <class T2>
        void Func(T2 t){ cout << t;}
    };
    int main(){
        A<int> a;
        a.Func('K');    //成员函数模板Func被实例化
        a.Func("hello");
        return 0;
    }
    ```
4. 类模板可以有非类型参数
    ```c++
    template <class T,int size>
    class CArray{
        T array[size];
    };
    CArray<double,40> a1;
    CArray<int,50> a2;  //a1,a2属于不同的类
    ```
### 7.7 类模板与派生、友元和静态成员变量
1. 类模板与派生
   - 类模板从类模板派生
    ```c++
    template <class T1,class T2>
    class A{
        T1 v1;T2 v2;
    };
    
    template <class T1,class T2>
    class B:public A<T2,T1>{
        T1 v3;T2 v4;
    };

    template <class T>
    class C:public B<T,T>{
        T v;
    };
    ```
    
   - 类模板从模板类派生
    ```c++
    template <class T1,class T2>
    class A{
        T1 v1;T2 v2;
    };

    template <class T>
    class B:public A<int,double>{ T v;};
    ```
   - 类模板从普通类派生
   - 普通类从模板类排成
2. 类模板与友元
    **这个用到的时候不会就自己查吧**
3. 类模板与static成员
   - 类模板中可以定义静态成员，那么从该类模板实例化得到的所有的类都包含同样的静态成员
   - 类模板产生的不同的类中的静态成员只是名字一样，但是放在内存的不同位置，不共享
 - --
## 第8周 标准模板库STL(一)
### 8.1 string类
1. string类
   - string类是模板类：
    typedef basic_string\<char\> string;
   - 头文件\<string\>
   - 初始化
     - string s1("hello");
     - string s2 = "hello";
     - string s3(8,'x');
     - 不能用字符初始化string,但可以用字符给string对象赋值
   - 长度 成员函数length();
   - 支持流读取运算符
     - string stringObject;
     - cin >> stringOBject;
   - 支持getline函数
     - string s;
     - getline(cin , s);

2. string的赋值和连接
   - 用 = 赋值
   - 用assign 成员函数复制
     - s2.assign(s1);
   - 用assign 成员函数部分复制
     - s2.assign(s1,1,3);   //s1中下标为1的字符开始复制3个字符给s2
   - 单个字符赋值
    s2[5] = s1[3] = 'a';
   - 逐个访问string对象中的字符
    ```c++
    string s1("hello");
    for(int i=0;i<s1.length();i++)
        cout << s1.at(i) << endl;   //at会做范围检查，[]不做范围检查
   - 用 + 连接字符串
   - 用append 成员函数连接字符串
     - s1.append(s2);
     - s1.append(s2,1,s2.size());
3. 比较string
   - 用关系运算符比较string的大小
     - ==, >, >=, <, <=, !=
   - 用成员函数compare比较
     - s1.compare(1,2,s2,0,3)   // s1 1-2 ; s2 0-3
4. 子串
   - 成员函数 substr
      - s2 = s1.substr(4,5);    // 下标4开始5个字符
5. 交换string
   - 成员函数 swap
     - s1.swap(s2);
6. 寻找string中的字符
   - 成员函数 find
     - string s1("hello world");
     - s1.find("lo");
     - s1中从前向后找"lo"第一次出现的地方，若找到返回'l'所在的位置下标，否则返回string::npos
     - s1.find("ll",2); //从下标为2开始找ll
   - 成员函数 rfind
     - 从后向前找，同find
   - 成员函数 find_first_of
     - s1.find_first_of("abc");
     - 从前向后找，abcd中任何一个字符第一次出现的位置下标
     - 同类有 find_last_of,find_first_not_of,find_last_not_of
7. 删除string中的字符
   - 成员函数 erase
   - s1.erase(4);   // 去掉下标4及以后的字符
8. 替换string中的字符
   - 成员函数 replace
     - s1.replace(2,3,"haha");   // 把下标2开始的3个字符换为 "haha"
     - s1.replace(2,3,"haha",1,2);
9.  在string中插入字符
    - 成员函数 insert
      - s1.insert(5,s2);    // 将s2插入s1下标5的位置
      - s1.insert(2,s2,5,3);    // 将s2中下标5开始的3个字符插入到s1下标2的位置
10. 转换成C语言式char *字符串
    - 成员函数 c_str
      - 返回const char *
    - 成员函数 data
      - 返回char *
11. 字符串拷贝
    - 成员函数 copy
    ```c++
    string s1("Hello world");
    int len = s1.length();
    char *p = new char[len+1];
    s1.copy(p2,5,0);
    // 从s1下标0的字符开始制作一个最长为5个字符长度的字符串副本，并将其赋值给p，返回值表明实际复制字符串的长度
    ```
12. 字符串流处理
    - #include \<sstream\>
    - 字符串输入流 istringstream
    ``` c++
    string input("Input test 123 4.6 A");
    istringstream inputString(input);
    string s1,s2; int i; double d;char c;
    inputString >> s1 >> s2 >> i >> d >> c;
    ```
    - 字符串输出流
    ```c++
    ostringstream outputString;
    int a = 10;
    outputString << "This " << a << " ok" << endl;
    ```

### 8.2 标准模板库STL概述(一)
1. STL中的基本概念
   - STL:常用数据结构和算法的模板的集合
   - 容器：可容纳各种数据类型的通用数据结构，是 **类模板**
   - 迭代器：可用于依次存取容器中的元素，类似于 **指针**
   - 算法：用来操作容器中的元素的 **函数模板**
     - sort()来对一个vector中的数据进行排序
     - find()来搜索一个list中的对象
2. 容器概述
    可用于存放各种类型的数据，都是类模板
   1. 顺序容器
    vector,deque,list
   2. 关联容器
    set,multiset,map,multimap
   3. 容器适配器
    stack,queue,priority_queue

    对象被插入容器中时，被插入的是对象的一个 **复制品**。放入容器的对象所属的类，往往应该重载 == 和 < 运算符。
3. 顺序容器简介
   - vector 头文件\<vector\>
    动态数组，内存连续存放，可在常数时间内随机存取，在尾部增删元素有较佳性能
   - deque 头文件\<deque\>
    双向队列，内存连续存放，可在常数时间内随机存取，在两端增删元素有较佳性能
   - list 头文件\<list\>
    双向链表，内存不连续存放，任何位置增删元素都可在常数时间完成，不支持随机存取
4. 关联容器简介
    - 元素是排序的
    - 插入任何元素，能按相应的规则来确定位置
    - 查找时有非常好的性能
    - 通常以平衡二叉树方式实现，插入和检索的时间都是O(log(N))
    - set/multiset 头文件\<set\>
        set即集合，不允许相同元素；multiset中允许相同的元素
    - map/multimap 头文件\<map\>
        map和set的不同在于map中存放的元素中有且仅有两个成员变量，一个名为first，另一个名为second，map根据first值对元素进行从小到大排序，并可快速根据first来检索元素
        map和multimap的不同在于是否允许相同first值的元素
5. 容器适配器简介
    - stack 头文件\<stack\>
        栈，后进先出
    - queue 头文件\<queue\>
        队列，先进先出，插入只可以在尾部进行，删除、检索和修改只允许从头部进行
    - priority_queue 头文件\<queue\>
        优先级队列，最高优先级元素总是第一个出列
6. 顺序容器和关联容器中都有的成员函数
    - begin 返回指向容器中第一个元素的迭代器
    - end 返回指向容器中最后一个元素后面的位置的迭代器
    - rbegin 返回指向容器中最后一个元素的迭代器
    - rend 返回指向容器中第一个元素前面的位置的迭代器
    - erase 从容器中删除一个或几个元素
    - clear 从容器中删除所有元素
7. 顺序容器中常用的成员函数
   - front 返回容器中第一个元素的引用
   - back 返回容器中最后一个元素的引用
   - push_back 在容器末尾增加新元素
   - pop_back 删除容器末尾的元素
   - erase 删除迭代器指向的元素（可能会使该迭代器失效），或删除一个区间，返回被删元素后面的那个元素的迭代器

### 8.3 标准模板库STL概述(二)
1. 迭代器
   - 用于指向顺序容器和关联容器
   - 迭代器用法和指针类似
   - 有const和非const两种
   - 通过迭代器可以读取它指向的元素
   - 通过非const迭代器可以修改其指向的元素
   - 定义一个容器类的迭代器的方法可以是
     - 容器类名::iterator 变量名;
     - 容器类名::const_iterator 变量名;
   - 访问一个迭代器指向的元素：
     - \* 迭代器变量名
   - 迭代器上可以执行++操作，以使其指向容器的下一个元素。如果迭代器到达了容器中的最后一个元素的后面，此时再使用它就会出错，类似于使用NULL或未初始化的指针一样
2. 迭代器示例
    ```c++
    vector<int> v;
    v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4);
    vector<int>::const_iterator i;
    for(i=v.begin(),i!=v.end();++i)
        cout << * i << ",";
    cout << endl;

    vector<int>::reverse_iterator r;    //反向迭代器
    for(r=v.rbegin();r!=v.rend();++r)
        cout << *r << ",";
    
    vector<int>::iterator j;    // 非常量迭代器
    for(j=v.begin();j!=v.end();++j) 
        *j = 100;
    ```
3. 双向迭代器
    若p和p1都是双向迭代器，则可对p,p1进行以下操作：
    - ++p,p++
    - --p,p--
    - *p
    - p = p1
    - p == p1,p != p1
4. 随机访问迭代器
    若p和p1都是随机访问迭代器，则可对p,p1进行以下操作：
    - 双向迭代器的全部操作
    - p += i
    - p -= i
    - p + i
    - p - i
    - p[i]
    - p < p1,p <= p1, p > p1; p >= p1
    - p - p1 :p1和p之间的元素个数

    |容器|迭代器类别|
    -------|-----
    vector|随机访问
    deque|随机访问
    list| 双向
    set/multiset|双向
    map/multimap|双向
    stack |不支持迭代器
    queue|不支持迭代器
    priority_queue|不支持迭代器

    注：有的算法，比如sort,binary_search需要通过 **随机访问迭代器**来访问容器中的元素，那么list及关联容器就不支持该算法。
5. 算法简介
   - 算法就是一个个 **函数模板** ，大多在\<algorithm\>中定义
   - 算法通过迭代器来操纵容器中的元素。许多算法可以对容器中的一个局部区间进行操作，因此需要两个参数，一个是起始元素的迭代器，一个是终止元素的后面一个元素的迭代器。比如排序和查找
   - 有的算法返回一个迭代器，比如find()算法，在容器中查找一个元素，并返回一个指向该元素的迭代器
   - 算法可以处理容器，也可以处理普通数组
6. 算法示例：find()
    ```c++
    template<class Init,class T>
    Init find(Init first,Init last,const T& val);
    ```
    - first和last这两个参数都是容器的迭代器，它们给出了容器中的查找区间起点和终点。[first,last)
    - 用 == 判断相等
    - 如果找到，返回的迭代器指向该元素，如果找不到，则该迭代器等于last
    ```c++
    int array[10] = {10,20,30,40};
    vector<int> v;
    v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4);
    vector<int>::iterator p;
    p = find(v.begin(),v.end(),3);
    if(p!=v.end())
        cout << *p << endl;
    ```

7. STL中“大”，“小”的概念
   - **关联容器**内部的元素是 **从小到大** 排序的
   - 有些算法要求其操作的区间是 **从小到大** 排序的，称为 **有序区间算法** 
     - binary_search
   - 有些算法会对区间进行 **从小到大** 排序，称为 **排序算法**
     - sort
   - 还有一些算法会用到“大”，“小”的概念
   - 使用STL时，在 **缺省** 的情况下，以下三个说法相等
     - x比y小
     - 表达式x\<y为真
     - y比x大
8. STL中“相等”的概念
   - 有时x和y相等等价于 **x==y为真**
     - 在未排序的区间上进行的算法，比如顺序查找find
   - 有时x和y相等等价于 **x小于y和y小于x同时为假**
     - 有序区间算法，如binary_search
     - 关联容器自身的成员函数find
### 8.4 vector,deque和list
1. vector示例程序
    ```c++
    #include <iostream>
    #include <vector>
    using namespace std;
    template<class T>
    void PrintVector( T s, T e)
    {
        for(;s!=e;++s)
            cout << *s << " ";
        cout << endl;
    }
    int main()
    {
        int a[5] = {1,2,3,4,5};
        vector<int> v(a,a+5);   //将数组a的内容放入v
        cout << "1)" << v.end() - v.begin() << endl;
        // 两个随机迭代器可以相减
        cout << "2)" ; PrintVector(v.begin(),v,end());
        // 2) 1 2 3 4 5
        v.insert(v.begin()+2,13);   // 在begin()+2位置插入13
        cout << "3)" ; PrintVector(v.begin(),v,end());
        // 3) 1 2 13 3 4 5
        v.erase(v.begin()+2);   // 删除位于begin()+2的元素
        cout << "4)" ; PrintVector(v.begin(),v,end());
        // 4) 1 2 3 4 5
        vector<int> v2(4,100);  // v2有4个元素，都是100
        v2.insert(v2.begin(),v.begin()+1,v.begin()+3);
        // 将v的一段插入v2开头
        v.erase(v.begin()=1,v.begin()+3);
        // 删除v的一个区间，即2,3
    }
    ```
2. 用vector实现二维数组
    ```c++
    vector<vector<int>> v(3);
    // vector有三个元素，每个元素都是vector<int>容器
    for(int i=0;i<v.size;++i)
        for(int j=0;j<4;++j)
            v[i].push_back(j);
    ```
3. deque
   - 所有适用于vector的操作
   - push_front
   - pop_front
4. 双向链表list
   - 在任何位置插入删除都是常数时间，不支持随机存取
   - 除了具有所有顺序容器都有的成员函数外，还支持8个成员函数
     - push_front
     - pop_front
     - sort (list不支持STL的算法sort)
     - remove 删除和指定值相等的所有元素
     - unique 删除所有和前一个元素相同的元素(要使元素不重复，这应该先sort再unique)
     - merge 合并两个链表，并清空被合并的那个
     - reverse 颠倒链表
     - splice 在指定位置前面插入另一链表的一个或多个元素，并在另一链表中删除被插入的元素
    ```c++
    #include <list>
    #include <iostream>
    #include <algorithm>
    using namespace std;
    class A{
        private :
            int n;
        public :
            A(int n_):n(n_){}
            friend bool operator<(const A& a1,const A& a2);
            friend bool operator==(const A& a1,const A& a2);
            friend ostream & operator <<(ostream& o,const A &a);
    };
    bool operator<(const A& a1,const A& a2){ return a1.n < a2.n; }
    bool operator==(const A& a1,const A& a2){ return a1.n == a2.n; }
    ostream & operator <<(ostream& o,const A &a){ o << a.n; return o;}

    template<class T>
    void PrintList( const list<T> & lst)
    {   //不推荐的写法，还是用两个迭代器作为参数更好，想在模板里写一个列表的引用，就这么写
        typename list<T>::const_iterator i;
        i = lst.begin();
        for(i=lst.begin();i!=lst.end();++i)
            cout << *i << ",";
    }

    int main(){
        list<A> lst1,lst2;
        lst1.push_back(1);  // 写了类型构造转换函数
    }
    ```
### 8.5 函数对象
1. 函数对象
   - 若一个类重载了运算符“()”,则该类的对象就成为函数对象
    ```c++
    class CMyAverage{
        public:
            double operator()(int a1,int a2,int a3){
                return (double)(a1+a2+a3)/3;
            }
    };
    CMyAverage average; //函数对象
    cout << average(3,2,3); // average.operator()(3,2,3)
    ```
2. 函数对象的应用示例
    ```c++
    #include <iostream>
    #include <vector>
    #include <algorithm>
    #include <numeric>
    #include <functional>
    using namespace std;

    int SumSquares( int total, int value )
    { return total + value * value; }

    template <class T>
    void PrintInterval(T first,T last)
    {
        for(;first!=last;++first)
            cout << *first << " ";
        cout << endl;
    }

    template <class T>
    class SumPowers
    {
        private:
            int power;
        public:
            SumPowers(int p):power(p){}
            const T operator()( const T& total,const T &value)
            {   // 计算value的 power次方，加到total上
                T v = value;
                for(int i=0;i<power-1;++i)
                    v=v*value;
                return total + v;
            }
    }；

    int main()
    {
        const int SIZE = 10;
        int a1[] = {1,2,3,4,5,6,7,8,9,10};
        vector<int> v(a1,a1+SIZE);
        cout << "1)";PrintInterval(v.begin(),v.end());
        int result = accumulate(v.begin(),v.end(),0,SumSquares);    // 函数作为参数不写括号
        cout << "2)平方和：" << result << endl;
        result = accumulate(v.begin(),v.end(),0,SumPowers<int>(3)); // 函数对象作为参数需要写括号，因为这里是对象，相当于SumPowers<int>3.operator()
        cout << "3)立方和：" << result << endl;
        return 0;
    }
    ```
3. STL的\<functional\>里还有以下函数对象类模板：
   - equal_to
   - greater
   - less
   这些模板可以用来生成函数对象
4. greater 函数对象类模板
    ```c++
   template <class T> 
   struct greater:public binary_function<T,T,bool>{
       bool operator()(const T& x,const T& y) const {
           return x>y;  // greater定义出的比大小的规则与平常的比大小的方式相反，通常以<为判断方法
       }
   };
   // binary_function定义：
   template<class Arg1,class Arg2,class Result>
   struct binary_functijon {
       typedef Arg1 first_argument_type;
       typedef Arg2 second_argument_type;
       typedef Result result_type;
   };
    ```
5. greater的应用
   list有两个sort成员函数
   - void sort();
        将list中的元素按 < 规定的比较方法升序排列
   - template <class Compare>
     void sort(Compare op);
     按op(x,y)的返回值比较，true->x在y前面
   - ` lst.sort(greater<int>()); // 按从大到小排序了`
6. 在STL中使用自定义的“大”，“小”关系
   关联容器和STL中许多算法，都是可以用函数或函数对象自定义比较器的。以下三种说法是等价的
   - x小于y
   - op(x,y)返回值为true
   - y大于x
7. 写出MyMax模板
    ```c++
    #include <iostream>
    #include <iterator>
    using namespace std;
    // 函数对象类
    class MyLess{
        public:
            bool operator(int a1,int a2){
                if((a1%10)<(a2%10))
                    return true;    // a1的个位数比a2小，那么认为a1比a2小
                else
                    return false;
            }
    };
    // 函数
    bool MyCompare(int a1,int a2)
    {
        if((a1%10)<(a2%10))
            return false;   // a1的个位数比a2小，那么认为a1比a2大
        else
            return true;
    }
    //MyMax模板
    template<class T,class Pred>
    T MyMax(T first,T last, Pred myless)
    {
        T tmpMax = first;
        for(;first!=last;++first)
            if(myless(*tmpMax,*first))
                tmpMax = first;
        return tmpMax;
    };

    int main(){
        int a[]={35,7,13,19,12};
        cout << *MyMax(a,a+5,Myless());
        cout << *MyMax(a,a+5,MyCompare);
        return 0;
    }
    ```
---
## 第9章 标准模板库STL(二)
### 9.1 set和multiset
1. 预备知识：pair模板
    ```c++
    template<class _T1,class _T2>
    struct pair{
        typedef _T1 first_type;
        typedef _T2 second_type;
        _T1 first;
        _T2 second;
        pair():first(),second(){}   // 无参构造函数,
        pair(const _T1& __a,const _T2& __b):first(__a),second(__b){}    
        template<class _U1，class _U2>
        pair(const pair<_U1,_U2>& __p):first(__p.first),second(__p.second){}    // 函数模板作为构造函数，就像复制构造函数？
    };
    ```
    map/multimap容器里放着的都是pair模板类的对象，且按first从小到大排序
    第三个构造函数用法示例：
    ```c++
    pair<int,int> p(pair<double,double> (5.5,4.6)); // p.first = 5,p.second = 4
    ```
2. multiset
    ```c++
    template<class Key,class Pred = less<Key>, class A = allocator<Key> >
    class multiset {};

    template<class T>
    struct less:public binary_function<T,T,bool>
    { bool operator()(const T& x,const T& y) {return x<y; } const; };
    ```
    - Pred类型的变量决定了multiset中的元素“一个比一个小”是怎么定义的。
    - multiset运行过程中，比较两个元素x,y的大小的做法，就是生成一个Pred类型的变量，假定为op,若表达式op(x,y)的返回值为true，则x比y小。
    - Pred的缺省类型是less\<Key\>，其实就是用 < 来比较 Key类型变量
3. multiset的成员函数
   - iterator find(const T & val); 在容器中查找值为val的元素，返回其迭代器。如果找不到，返回end()。
   - iterator insert (const T & val); 将val插入到容器中并返回其迭代器。
   - void insert (iterator first,iterator last); 将区间[first,last)插入容器。
   - int count(const T & val); 统计有多少个元素的值与val相等。
   - iterator lower_bound(const T & val); 查找一个最大的位置it，使得[begin(),it)中所有的元素都比val小。
   - iterator upper_bound(const T & val); 查找一个最小的位置it，使得[it,end()) 
   - pair\<iterator,iterator\> equal_range(const T & val); 同时求得lower_bound和upper_bound。
   - iterator erase(iterator it); 删除it指定的元素，往往会返回其后面元素的迭代器。
4. multiset的一个错误使用
    ```c++
    #include <set>
    using namespace std;
    class A{};
    int main(){
        multiset<A> a;   // 等价于multiset<A,less<A>> a;
        a.insert(A());  //error ,less用 < 进行比较，这就要求A的对象能用<比较大小，即适当重载了 <
    }
    ```
5. multiset的用法示例
    ```c++
    template<class T>
    void Print(T fisrt,T last)
    {
        for(;first!=last;++first)
            cout<< *first << " ";
        cout << endl;
    }
    class A{
        private:
            int n;
        public:
            A(int n_){ n = n_};
            friend bool operator<( const A & a1,const A & a2){ return a1.n < a2.n;}
            friend ostream & operator<<( ostream & o,const A & a2){ o << a2.n; return o;}
            friend class MyLess;
    };
    struct MyLess{
        bool operator()( const A & a1, const A & a2 )    // 这是个函数对象
        { return (a1.n%10) < (a2.n%10);}
    };

    typedef multiset<A> MEST1;  // MEST1用 < 比较大小
    typedef multiset<A,MyLess> MEST2;   // MEST2 用 MyLess::operator()比较大小，反正这里写一个函数对象类的名字就可以了
    int main()
    {
        const int SIZE = 6;
        A a[SIZE] = {4,22,19,8,33,40};
        MSET1 m1;
        m1.insert(a,a+SIZE);
        m1.insert(22);
        cout << "1) " << m1.count(22) << endl; //输出 1) 2
        cout << "2) "; Print(m1.begin(),m1.end()); //输出 2) 4 8 19 22 22 33 40
        //m1元素：4 8 19 22 22 33 40
        MSET1::iterator pp = m1.find(19);
        if(pp!=m1.end())    // 条件为真说明找到
            cout << "found" << endl;
        cout << "3)" << *m1.lower_bound(22) << "," << *m1.upper_bound(22) << endl;
        //输出 3) 22,33
        pp = m1.erase(m1.lower_bound(22),m1.upper_bound(22));   //[22,33)
        cout << "4) "; Print(m1.begin(),m1.end()); //输出 4) 4 8 19 33 40
        cout << "5) "; cout << * pp << endl; //输出 5) 33
        MSET2 m2; // m2里的元素按n的个位数从小到大排
        m2.insert(a,a+SIZE);
        cout << "6) "; Print(m2.begin(),m2.end()); //输出 6) 40 22 33 4 8 19
        return 0;
    }
    ```
5. set
    和Multiset比只是不允许有相同元素
    ```c++
    #include <iostream>
    #include <set> 
    using namespace std;
    int main() {
        typedef set<int>::iterator IT;
        int a[5] = { 3,4,6,1,2 };
        set<int> st(a,a+5); // st里是 1 2 3 4 6
        pair< IT,bool> result;
        result = st.insert(5); // st变成 1 2 3 4 5 6    返回一个pair类型对象，first为值，second为是否插入成功
        if( result.second ) //插入成功则输出被插入元素
        cout << * result.first << " inserted" << endl; //输出: 5 inserted
        if( st.insert(5).second ) cout << * result.first << endl;
        else
        cout << * result.first << " already exists" << endl; //输出 5 already exists
        pair<IT,IT> bounds = st.equal_range(4);     //返回一个pair类型对象
        cout << * bounds.first << "," << * bounds.second ; //输出：4,5
        return 0;
    }
    ```
### 9.2 map和multimap
1. multimap
    ```c++
    template<class Key,class T,class Pred=less<Key>,class A=allocator<T>>
    class multimap{
        ...
        typedef pair<const Key,T> value_type;
        ...
    };  //Key代表关键字的类型
    ```
    - multimap中的元素由<关键字，值>组成，每一个元素都是一个pair对象，关键字就是first成员变量，其类型为Key
    - multimap中允许多个元素的关键字相同。元素按照first成员变量从小到大排列，缺省情况下用less\<Key\>定义关键字的“小于”关系。
2. multimap示例
    ```c++
    #include <iostream>
    #include <map>
    using namespace std;
    int main(){
        typedef multimap<int,double,less<int> > mmid;
        mmid pairs;
        cout << "1)" << pairs.count(15) << endl;  // 求关键字等于某值的元素个数
        pairs.insert(mmid::value_type(15,2.7)); //typedef pair<const Key,T> value_type;
        pairs.insert(mmid::value_type(15,99.3));
        cout << "2)" << pairs.count(15) << endl;
        for(mmid::const_iterator i = pairs.begin();i!=pairs.end();i++)
            cout << "(" << i->first << "," << i->second << ")" << ",";
    }
3. multimap例题
    一个学生成绩录入和查询系统，接受以下两种输入：
    Add name id score
    Query score

    name是一个字符串，中间没有空格，代表学生姓名。id是一个整数，代表学号。score是个整数，代表分数。学号不会重复，名字和分数都可能重复。
    第二种输入表示要查询，输出已有记录中 分数比score低的最高分获得者的姓名学号分数。如果多个学生满足条件，就输出学号最大的那个学生的信息。如果找不到就输出Nobody
    ```c++
    #include <iostream>
    #include <map>
    #include <string>
    using namespace std;

    class CStudent{
        public:
            struct CInfo
            {
                int id;
                string name;
            };
            int score;
    };
    typedef multimap<int,CStudent::CInfo> MAP_STD;
    int main(){
        MAP_STD mp;
        CStudent st;
        string cmd;
        while (cin >> cmd){
            if(cmd=="Add"){
                cin >> st.info.name >> st.info.id >> st.score;
                mp.insert(MAP_STD::value_type(st.score,st.info));   // mp.insert(make_pair(st.score,st.info));也可以
                // make_pair()不需要类型就可以构成一个pair对象，所以就很方便
            }
            else if(cmd=="Query"){
                int score;
                cin >> score;
                MAP_STD::iterator p = mp.lower_bound(score);
                if(p!=mp.begin()){
                    --p;
                    score = p->first;
                    MAP_STD::iterator maxp = p;
                    for(;p!=mp.begin()&&p->first==score;--p)
                        if(p->second.id > maxp->second.id)
                            maxp = p;
                    if(p->first == score)   // 如果是因为p == mp.begin()而中断，那么应该再进行一次比较
                        if(p->second.id > maxp->second.id)
                            maxp = p;
                    cout << maxp->second.name << " " << maxp->second.id << " " << maxp->first << endl;
                }
                else
                    cout << "Nobody" << endl;
            }
        }
        return 0;
    }
    ```
4. map
    - map中的元素都是pair模板类对象，关键字first各不相同。其余和multimap相同
    - 有成员函数\[\],假设pairs是map模板类的对象,pairs[key]。若存在关键字为key的元素，则返回其元素的值(second成员变量)的引用。否则插入一个关键字为key的元素，其值用无参构造函数初始化，并返回其值的引用。
    - 如map\<int,double\> pairs; pairs[50] = 5;会修改pairs中关键字为50的元素，使其值变成5。若不存在关键字等于50的元素，则插入此元素，并使其值变为5。
    ```c++
    //map的四种插入方法总结
    map<int,string> mp;
    // 方法一：pair
    mp.instert(pair<int,string>(1,"one")); 
    // 方法二：make_pair
    mp.instert(make_pair(2,"two"));
    // 方法三：value_type
    mp.instert(map<int,strint>::value_type(3,"three"));
    // 方法四：[]
    mp[4] = "four";
    // 当前三种方法出现插入重复值时，不起作用。方法四会覆盖，即修改其元素的值。
    ```
### 9.3 容器适配器
1. stack
   - stack是后进先出的数据结构，只能插入，删除，访问栈顶元素。
   - 可用vector,list,deque实现，默认用deque
   ```c++
    template<class T,class Cont = deque<T> >
    class stack{};
   ```
   - stack上可以进行的操作
     - push 插入元素
     - pop 弹出元素
     - top 返回栈顶元素的引用
2. queue
   - 先进先出
   - push发生在队尾
   - pop，top发生在队头
   - 有back成员函数，可以返回队尾元素的引用
3. priority_queue
    ```c++
    template<class T,class Container = vector<T>,class Compare = less<T> >
    class priority_queue;
    ```
    - 和queue类似，可以用vector和queue实现，默认用vector
    - priority_queue通常用堆排序技术实现，保证最大的元素总是在最前面。所以执行pop操作时，删除的时最大的元素，执行top时返回的时最大元素的 **常引用**。默认的元素比较器是less\<T\>
    - push,pop的时间复杂度为O(logn)
    - top()的时间复杂度为O(1)
4. 容器适配器的元素个数
    - empty() 
    - size()
### 9.4 算法(一)
1. 不变序列算法
   - 不会修改容器或对象
   - 适用于顺序容器和关联容器
   - 时间复杂度为O(n)

   - min 求两个对象中较小的
   - max
   - min_element 求区间中的最小值
    用<做比较器，最小指没有元素比它小
    因为即使a!=b,a\<b,b\<a也是有可能的
   - max_element
    用<做比较器，最大指不小于其他元素
   - for_each 对区间中每个元素都做某种操作
    ```c++
    template<class InIt, class Fun>
    Fun for_each(InIt first,Init last,Fun f);
    // 对区间的每个元素e，执行f(e)，要求f(e)不能改变e
    ```
   - count 计算区间中等于某值的元素的个数，用 ==
   - count_if 计算区间中符合某种条件的元素的个数
   - find 在区间中查找等于某值的元素，用 == 
    ```c++
    template<class InIt,class T>
    InIt find(InIt first ,InIt last, const T & val);
    // 如果没找到就返回last
    ```
   - find_if 
    ```c++
    template<class InIt,class Pred>
    InIt find_if(InIt first,InIt last,Pred pr);
    // 返回迭代器i，其中pr(*i) == true
    ```
   - find_end
   - find_first_of
   - search 在区间中查找另一个区间第一次出现的位置
   - equal 判断两个区间是否相等（可自定义比较器）
   - mismatch 逐个比较两个区间的元素，返回第一次发生不相等的两个元素的位置（可自定义比较器）
2. 变值算法
   - 会修改区间的值
   - 那个区间不可以是输入关联容器的，因为本来就是排好序的，不能改了

   - for_each   和之前的for_each中的函数参数中的参数相比，一个是const，这个就不是const
   - copy 复制一个区间到别处
   - copy_backward 复制一个区间到别处，但目标区间是从后往前被修改的（从后往前拷贝）。当两个区间有重叠时，为了防止重叠部分还未拷贝就被覆盖掉
   - transform 将一个区间的元素变形到另一个区间
    ```c++
    template<class InIt,class OutIt,class Unop>
    OutIt transform(InIt first,InIt last,OutIt x,Unop uop);
    ```

    - 对[first,last)中的每个迭代器I
       - 执行uop(*I); 并将结果依次放入从x开始的地方
       - 要求uop(*I) 不得改变\*I的值
    本模板返回值是一个迭代器，即x+last-first 
       - x和first可以相等
   - swap_ranges 交换两个区间内容
   - fill 用某个值填充区间
   - fill_n 用某个值替换区间中的n个元素
   - generate 用摸个操作的结果填充区间
   - generate_n
   - replace 将区间中的某个值替换为另一个值
   - replace_if 将区间中符合某种条件的值替换成另一个值
   - replace_copy 将一个区间拷贝到另一区间，拷贝时对某个值换成新值拷贝过去
   - replace_copy_if 

   - 示例
    ```c++
    #include <vector>
    #include <iostream>
    #include <numeric>
    #include <list>
    #include <algorithm>
    #include <iterator>
    using namespace std;
    class CLessThen9{
        public:
            bool operator()(int n){return n<9;}
    };  // 自定义的函数对象类，判断n是否小于9
    void outputSquare(int value){ cout << value * value << " ";}
    int calculateCube(int value){ return value*value*value;}
    int main(){
        const int SIZE = 10;
        int a1[] = {1,2,3,4,5,6,7,8,9,10};
        int a2[] = {100,2,8,1,50,3,8,9,10,2};
        vector<int> v(a1,a1+SIZE);
        ostream_iterator<int> output(cout," "); //一个类模板啦，实例化成整形参数，就是以后用这个类输出的东西都是Int类型的，这个对象就是以后交给Output的东西都会交给cout,然后输出一个整数就输出一个空格
        random_shuffle(v.begin(),v.end());  //把一个区间内的值随机打乱
        cout << endl << "1)";
        copy(v.begin(),v.end(),output); //这里会导致输出，输出刚刚被随机的结果和空格
        copy(a2,a2+SIZE,v.begin()); // copy操作要求目标区间有足够的空间，否则会像数组越界一样出错
        cout << endl << "2)";
        cout << count(v.begin(),v.end(),8);
        cout << endl << "3)";
        cout << count_if(v.begin(),v.end(),CLessThen9());   // CLessThen9是个类，加上括号就是个无名的对象，假设现在他叫op,那么传入count_if里， 就会考察op(e)是否为true，那么op(e)呢就是op.operator(e)
        cout << endl << "4)";
        cout << *(min_element(v.begin(),v.end()));
        cout << endl << "5)";
        cout << *(max_element(v.begin(),v.end()));
        cout << endl << "6)";
        cout << accumulate(v.begin(),v.end(),0);
        cout << endl << "7)";
        for_each(v.begin(),v.end(),outputSquare);
        vector<int> cubes(SIZE);    // 初始化SIZE个元素，其值不确定
        transform(a1,a1+SIZE,cubes.begin(),calculateCube);  //将a1经过变化给cubes
        cout << endl << "8)";
        copy(cubes.begin(),cubes.end(),output);
        return 0;
    }
    ```
   - 对刚刚奇怪的copy的解释
    `ostream_iterator<int> output(cout," ");`
    定义了一个ostream_iterator对象，可以通过cout输出以“ ”分隔的一个个整数
    `copy(v.begin(),v.end(),output);`
    导致v的内容在cout上输出
    - copy的源代码：
    ```c++
    template<class _II,class _OI>
    inline _OI copy(_II_F,_II_L,_OI_X)
    {
        for(l_F!=_L;++_X;++_F)
            *_X = *_F;
        return (_X);
    }
    ```
    - My_ostream_iterator模板类
    ```c++
    template<class T>
    class My_ostream_iterator:public iterator<output_iterator_tag,T>{
        private:
            string sep; //分隔符
            ostream & os;
        public:
            My_ostream_iterator(ostream &o,string s):sep(s),os(o){}
            void operator ++(){};   //++只需要有定义即可，不需要他做什么事
            My_ostream_iterator & operator *(){ return *this;}
            My_ostream_iterator & operator =(const T & val)
            {
                os << val << sep; return *this;
            }
    };
    ```
### 9.5 算法(二)
3. 删除算法
   - 删除一个容器里的某些元素
   - 不会使容器里的元素减少
     - 将所有应该被删除的元素看做空位
     - 用留下的元素从后往前移，依次去填空位
     - 元素往前移后，它原来的位置也是空位
     - 也应该由后面的留下来的元素来填上
     - 最后没被填上的空位，维持其原来的值不变
   - 不应作用于关联容器

   - remove 删除区间中等于某个值的元素
   - remove_if 
   - remove_copy 拷贝区间到另一个区间，等于某个值的元素不拷贝
   - remove_copy_if
   - unique 删除区间中连续相等的元素，只留下一个（可自定义比较器）
    ```c++
    template<class FwdIt>
    FwdIt unique(FwdIt first,FwdIt last);   // 用==比较是否相等

    template<class FwdIt,class Pred>
    FwdIt unique(FwdIt first,FwdIt last,Pred pr);   //pr(x,y)为true则相等
    
    // 返回值是迭代器，指向元素删除后的区间的最后一个元素的后面
    ```

   - unique_copy

   - 示例
    ```c++
    int main(){
        int a[5] = {1,2,3,4,5};
        int b[6] = {1,2,3,2,5,6};
        ostream_iterator<int> oit(cout,",");
        int *p = remove(a,a+5,2);   //返回最后一个元素的后面
        cout << "1)" ; copy(a,a+5,oit); cout << endl;
        // 1)1,3,5,2,5,
        cout << "2)" << p-a << endl;
        // 2)3
        vector<int> v(b,b+6);
        remove(v.begin(),v.end(),2);
        cout << "3)"; copy(v.begin(),v.end(),oit); cout << endl;
        // 3)1,3,5,6,5,6,
        cout << "4)"; cout << v.size() << endl;
        // 4)6 v中元素并没有减少
        return 0；
    }
    ```
4. 变序算法
   - 不改变元素的值
   - 不适用于关联容器
   - O(n)

   - reverse 颠倒
   - reverse_copy 把一个区间颠倒后的结果放在新区间，原区间不变
   - next_permutation 将区间改变为下一个排列（可自定义比较器）
    ```c++
    string str = "231";
    while(next_permutation(str.begin(),str.end()))
        cout << str << endl;
    // 312
    // 321
    ```
   - prev_permutation
   - random_shuffle 打乱顺序，只能用于随机访问的容器
   - stable_patition
     - 把区间内满足某个条件的元素移到前面
     - 不满足该条件的移到后面
     - 两部分元素的内部次序保持不变
5. 排序算法
   - 一般是O(nlogn)
   - 必须是随机访问迭代器，也就是不能用于list，list要用他自己的成员函数了
   - 这里都是可以自定义比较器的，默认是用小于号

   - sort 从小到大排序，快排
   - stable_sort 稳定的排序 归并排序
   - partial_sort 对区间部分排序，直到最小的n个元素就位
   - partial_sort_copy 拷贝到别处
   - nth_element 对区间部分排序，使得第n小的元素（n从0开始）就位，而且比他小的都在他前面，比他大的都在他后面
6. 有序区间算法
   - 要求所操作的区间已经是从小到大排好序的
   - 要随机访问迭代器的支持
   - 也就是不用与关联容器和list
   - 默认用小于号，可自定义吧。

   - binary_search 判断区间中是否包括某个元素 x小于y，y小于x都不成立
     - 折半查找
     - O(logn)
     - 返回值是布尔类型，是否找到
   - includes 判断是否一个区间中的每个元素都在另一个区间中 first2,last2中的每个元素是否都在first1,last1中，用自定义比较器或小于号
   - lower_bound O(logn)
   - upper_bound
   - equal_range 同时获取lower_bound upper_bound
   - merge 合并两个有序区间到第三个区间 也可以自定义比较器，默认用小于号
   - set_union 将两个有序区间的并拷贝到第三个区间
   - set_intersection 交
   - set_difference 差
   - set_symmertric_difference 将两个有序区间的对称差拷贝到第三个区间，就是并减去交
   - inplace_merge 将两个连续的有序区间原地合并到一个区间
7. bitset
    ```c++
    template<size_t N>
    class bitset{};
    ```
    - 实际使用时，N是一个整型常数
    - 如:
      - bitset<40> bst;
      - bst是一个由40位组成的对象
      - 用bitset的函数可以方便地访问任意一位
    ---
## 第10章 C++新特性和高级用法
### 10.1 C++新特性(1)
1. 统一的初始化方法
    ```c++
    int arr[3]{1,2,3};
    vector<int> {1,2,3};
    map<int,string> mp{{1,"a"},{2,"b"}};
    string str{"hello world"};
    int *p = new int[20]{1,2,3};
    struct A{
        int i,j;
        A(int m,int n):i(m),j(n){}
    };
    A func(int m,int n){return {m,n};} // {m,n}返回一个临时A对象
    A* pa = new A{3,7};
    ```
2. 成员变量默认初始值
    ```c++
    class B
    {
        public:
        int m = 1234; // 这里
        int n;
    };
    ```
3. auto关键字
    用于定义变量，编译器可以自动判断变量的类型
    ```c++
    auto i = 100;
    auto p = new A();

    map<string,int,greater<string>> mp;
    for( auto i = mp.begin(),i!=mp.end();++i) 
        cout << i->first ;
    // i的类型是 map<string,int greater<string>>::iterator

    class A{};
    A operator+(int n,const A& a){
        return a;
    }
    template <class T1,class T2>
    auto add(T1 x,T2 y)->decltype(x+y){return x+y;}
    ```
4. decltype关键字
    返回表达式的类型
    decltype(x) 返回x的类型
    decltype((x)) 返回x的引用
5. 智能指针shared_ptr
   - 头文件 \<memory\>
   - 是一个类模板，可以让shared_ptr对象托管一个new运算符返回的指针
   - shared_ptr\<T\> ptr(new T);    // T是类型
   - 这时ptr就可以像T*类型的指针一样使用
   - 不用担心释放内存delete的事
   - 多个shared_ptr可以同时托管一个指针，当无shared_ptr对象托管该指针时，就会delete该指针
   - shared_ptr不能托管动态分配的数组的指针，否则会出错
    ```c++
    #include <memory>
    #include <iostream>
    using namespace std;
    struct A{
        int n;
        A(int v=0):n(v){}
        ~A(){count << n << "destructor" << endl;}
    };
    int main(){
        shared_ptr<A> sp1(new A(2));    //sp1托管A(2)
        shared_ptr<A> sp2(sp1);     //sp2也托管A(2)
        shared_ptr<A> sp3;
        A *P = sp1.get();   //p指向A(2)
        sp3 = sp1;  //sp3也托管A(2)
        sp1.reset();    //sp1放弃托管A(2),此时sp1相当于空指针
        A *q = new A(3);
        sp1.reset(q);   //sp1托管q
        shared_ptr<A> sp4(sp1); //sp4托管A(3)
        shared_ptr<A> sp5;
        // sp5.reset(q); 不妥，会导致程序出错
        // 因为这么做，系统并不会增加ptr对q的托管计数，当结束程序时，会delete q两次
        sp1.reset();
        sp4.reset();    //1和4都放弃托管A(3) 这时A(3)会被delete
        return 0；  //程序结束，A(2)会被delete
    }
    ```
6. 空指针nullptr
7. 基于范围的for循环
    ```c++
    struct A { int n; A(int i):n(i){}};
    int main(){
        int ary[] = {1,2,3,4,5};
        for(int & e:ary)    // 会修改e的值
            e *= 10;
        for(int e:ary)  // 不会修改e的值
            cout << e << ",";
        vector<A> st(ary,ary+5);
        for( auto & it:st)
            it.n *= 10;
        for(A it:st)
            cout << it.n << ",";
        return 0;
    }
    ```
8. 右值引用和move语义
   - 右值：不能取其地址的表达式 就是右值
    ```c++
    class A{};
    A & r = A(); //error A()是无名变量，是右值
    A && r = A(); //ok r是右值引用
    ```
   - 目的：提高程序运行的效率，减少需要进行深拷贝的对象进行深拷贝的次数
    ```c++
    class String{
        public:
            char * str;
            String():str(new char[1]){ str[0] = 0;}
            String(const char * s){
                str = new char[strlen(s) + 1];
                strcpy(str,s);
            }
            String(const String &s){
                cout << "copy constructor called" << endl;
                str = new char[strlen(s.str)+1];
                strcpy(str,s.str);
            }
            String & operator=(const String & s){
                if(str!=s.str){
                    delete [] str;
                    str = new char[strlen(s.str) + 1];
                    strcpy(str,s.str);
                }
                return * this;
            }
            // move constructor
            // str直接指向s.str指向的地方，然后s.str指向一个新生成的地方
            String (String && s):str(s.str){
                s.str = new char[1];
                s.str[0] = 0;
            }
            // move assigment
            String & operator=(String &&s){
                if(str!=s.str){
                    delete [] str;
                    str = s.str;
                    s.str = new char[1];
                    s.str[0] = 0;
                }
                return *this;
            }
            ~String(){ delete [] str;}
    };

    template<class T>
    void MoveSwap(T &a,T &b){
        // 交换两个值，不需要复制构造函数，只要交换指针指的位置就OK了吧
        // 但是这里a,b的值会被修改，需要注意
        T tmp(move(a)); // std::move(a)为右值，会调用move constructor
        // 这里如果不写move(a) ,直接写a，那么会调用复制构造函数，大概率会用深拷贝啦，就比较耗时
        // move(),stl里的一个模板，将一个左值变为一个右值，就不会调用复制构造函数了，调用移动构造函数(Stirng && s)
        a = move(b); // move(b)是右值，会调用move assigment
        b = move(tmp); // move(tmp)是右值，会调用move assigment
    }

    int main(){
        String s;
        s = String("ok"); // String("ok")是右值，会调用move assigment
        String && r = String("this");
        cout << r.str << endl;
        String s1 = "hello",s2 = "world";
        MoveSwap(s1,s2);    // 调用了move constructor ,move assigment,move assigment
        cout << s2.str << endl; // 成功输出hello,避免了三次深拷贝
    }
    ```
### 10.2 C++新特性(2)
1. 无序容器 哈希表
   - 头文件\<unordered_map\>
   - 和map一样，但是效率更高
   - 插入和查询的时间复杂度几乎是常数
2. 正则表达式
   - 头文件\<regex\>
   ```c++
   regex reg("b.?p.*k");
   cout << regex_match("bopggk",reg) << endl;   // 输出1，表示匹配成功。
   string s = "hello";
   cout << fegex_match(s,reg) << endl   ;   // 输出0，表示匹配失败。
   ```
3. lambda表达式
   - 形式
    `[外部变量访问方式说明符](参数表)->返回值类型 {}`
   - [=] 以传值的形式使用所有外部变量
   - [] 不使用任何外部变量
   - [&] 以引用形式使用所有外部变量
   - [x,&y] x以传值的形式，y以引用的形式
   - [=,&x,&y] x,y以引用形式，其余变量以传值形式
   - [&,x,y] x,y以传值形式，其余变量以引用形式
    ```c++
    int main(){
        int x=100,y=200,z=300;
        cout << [](double a,double b){ return a+b;}(1.2,2.5) << endl;
        auto ff = [=,&y,&z](int n){
            cout << x << endl;  // 输出100
            y++;z++;
            return n*n;
        };
        cout << ff(15) << endl; // 输出225
        cout << y << "," << z << endl;  // 输出201,301
        int a[4] = {4,2,11,33};
        sort(a,a+4,[](int x,int y)->bool {return x%10 < y%10;});    // lambda表达式的优势
        for_each(a,a+4,[](int x){ cout << x << " ";});
    }

    int main(){
        vector<int> a{1,2,3,4};
        int total = 0;
        for_each(a.begin(),a.end(),[&](int &x){total += x; x *= 2;});   // 将每一个a的元素 作为参数 传入lambda表达式,&是为了total
        cout << total << endl;
        for_each(a.begin(),a.end(),[](int x){cout << x << " ";});
    }
    // 实现递归斐波那契数列的第n项
    functon<int(int)> fib = [&fib](int){ return n<=2?1: fib(n-1) + fib(n-2);};  //这里不能用auto，因为递归了
    // function<A(B)> 表示返回值为A，有一个类型B参数的函数 

    ```
### 10.3 强制类型转换
    原来的类型转换，比如(int)，无法判断类型转换的风险高低，而且不便于找错
1. static_cast
   - 用来进行比较自然和低风险的转换，比如整型和实数型、字符型之间互相转换
   - 不能用指针之间互相转换，也不能用与整型和指针的互相转换，也不能用于引用之间的转换
    ```c++
    class A{
        public:
            operator int() { return 1;} 
            operator char*(){ return NULL;} // 类型强制转换运算符被重载为函数时，不写返回值
    };
    int main(){
        A a;
        int n;
        char *p = "hello";
        n = static_cast<int>(3.14); // 等价于(int)(3.14)
        n = static_cast<int>(a);    // 调用a.operator int,n的值变为1
        p = static_cast<char *>(a);
        p = static_cast<int>(p);    // error
        p = static_cast<char *>(n);   // error
    }
    ```
2. reinterpret_cast (重新解释_cast)
   - 不同类型指针之间的转换
   - 不同类型引用之间的转换
   - 指针和能容纳的下指针的整数类型之间的转换
   - 执行逐个比特拷贝的操作
    ```c++
    class A{
        public:
            int i;
            int j;
            A(int n):i(n),j(n){}
    };
    int main(){
        A a(100);
        int &r = reinterpret_cast<int &>(a);    //强行让r引用a
        r = 200;    //把r引用的那里的前4个字节变为200，a.i变为了200
        
        int n = 300;
        A * pa = reinterpret_cast<A*>(& n); //强行让pa指向n
        pa->i = 400;    // n变为400
        pa->j = 500;    // 此条语句不安全，很可能导致程序崩溃
    }
    ```
3. const_cast
   - 用来去除const属性的转换   
    ```c++
    const string s = "inception";
    string & p = const_cast<string &>(s);
    string * ps = const_cast<string *>(&s);
    ```
4. dynamic_cast (动态的_cast)
   - 专门用于将 **多态基类** 的指针或引用，强制转换为派生类的指针或引用，而且能够检查转换的安全性
   - 一个指向基类对象的基类指针转换为派生类就是不安全的
   - 对于不安全的指针转换，转换结果返回NULL指针
   - 不能用于非多态基类的指针或引用
   - 多态基类就是包含虚函数的基类呗
    ```c++
    class Base{
        public:
            virtual ~Base(){}
    };
    class Derived:public Base{};
    int main(){
        Base b;
        Derived d;
        Derived * pd;
        pd = reinterpret_cast<Derived*>(&b); // 强制转换了这个指针，不安全
        pd = dynamic_cast<Derived*>(&b);
        if(pd == NULL)
        // 结果会是NULL 因为&b这个基类指针不指向派生类对象，而是指向基类对象，此转换不安全
            cout << "unsafe" << endl;
        Base *pb = &d;  // 一个基类指针指向一个派生类对象
        pd = dynamic_cast<Derived*>(pb);    // 安全的转换
    }
    ```
    - 对于基类引用到派生类引用的转换，也不会有NULL了
    `Derived & r = dynamic_cast<Derived &>(b);`
    - 如果不安全，就会抛出异常，下节课说
### 10.4 异常处理
1. 用try/catch处理异常
    ```c++
    double m,n;
    cin >> m >> n;
    try{    // 如果try块没有抛出异常，就不会执行任何的catch块。 如果抛出异常，从上到下匹配catch块，或者没进入任何catch块，直接崩溃
        cout << "before dividing." << endl;
        if(n==0)
            throw -1;   // 抛出int类型异常,会进入catch(int e)
        else if(m==0)
            throw -1.0; // double类型异常
        else
            cout << m/n << endl;
    }
    catch(double d){// double的异常
        cout << "catch(double)" << d << endl;
    }
    catch(int e){
        cout << "catch(int)" << e << endl;
    }
    catch(...){// 捕获任何异常
        cout << "catch(...)" << endl;
    }
    cout << "fininshed" << endl; // 抛出异常后，进入catch(e),然后执行这条语句
    ```
2. 异常的再抛出
   - 抛出的异常可以在本函数内就被catch块捕获并处理，就不会抛给上一层的函数
   - 如果异常没有在本函数中处理，那么就会抛给上一层函数
    ```c++
    class CException{
        public:
            string msg;
            CException(string s):msg(s){}
    };
    double Devide(double x ,double y)
    {
        if(y==0)
            throw CException("devided by zero");
        cout << "in Devide" << endl;
        return x/y;
    }
    int CountTax(int salary)
    {
        try{
            if(salary < 0)
                throw -1;
            cout << "counting tax" << endl;
        }
        catch(int){
            cout << "salary < 0" << endl;
        }
        cout << "tax counted" << endl;
        return salary * 0.15;
    }
    int main(){
        double f = 1.2;
        try{
            CounTax(-1);
            f = Devide(3,0);    // 并不会修改f的值了
            cout << "end of try block" << endl;
        }
        catch(CException e){    // 可以接收来自Devide(3,0)的异常
            cout << e.msg << endl;
        }
        cout << f << endl;  // 1.2
        return 0;
    }
    ```
3. C++标准异常类
    \<stdexcept\>
    exception->
       - bad_typeid
       - bad_cast
       - bad_alloc
       - ios_base::failure
       - logic_error -> out_of_range

   - bad_cast 在发生不安全的强制类型转换时(dynamic_cast)，会抛出异常
    ```c++
    try{
        Derived & rd = dynamic_cast<Derived&>(b);
    }
    catch(bad_cast& e)
        cerr<< e.what() << endl;    // e.what()返回一个字符串，是和异常有关的信息
    ```
   - bad_alloc 在new运算符进行动态内存分配时，如果没有足够的内存就会引发该异常。一般new都不会失败
   - out_of_range 用vector或string的at成员函数，如果下标越界则会抛出异常
    ```c++
    vector<int> v(10);
    try{
        v.at(100) = 100;
    }
    catch(out_of_range & e){
        cerr << e.what() << endl;
    }
    ```